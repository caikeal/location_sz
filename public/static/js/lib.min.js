/**
 * Beacon 模块
 * @param { Number } x
 * @param { Number } y
 * @param { Number } major
 * @param { Number } minor
 * @param { Number } measuredPower
 * @param { Number|String } floorid
 */
class Beacon {
	constructor(x = 0, y = 0, major = 0, minor = 0, measuredPower = -59, floorid = '1') {
		this.x = x;
		this.y = y;
		this.major = major;
		this.minor = minor;
		this.measuredPower = measuredPower;
		this.floorid = floorid;

		this.rssiChain = [];
		this.accuracyChain = [];
	}

	get effCount() {
		return this.rssiChain.filter((item) => {
			return item < 0;
		}).length;
	}

	get aveRssi() {
		let sumRssi = 0;
		let counter = 0;
		for (let i = 0; i < this.rssiChain.length; i++) {
			if (this.rssiChain[i] < 0) {
				sumRssi = sumRssi + this.rssiChain[i];
				counter++;
			}
		}
		if (counter != 0) {
			return sumRssi / counter;
		} else {
			return  0;
		}
	}

	get accuary() {
		let sumAcc = 0;
		let counter = 0;
		for (let i = 0; i < this.accuracyChain.length; i++) {
			sumAcc = sumAcc + this.accuracyChain[i];
			counter++ 
		}
		if (counter != 0) {
			return sumAcc / counter; 
		} else { 
			return 0;
		}
	}

	get distance() {
		let distance = 0;
		let ratio = this.aveRssi / this.measuredPower;
		let d = 0.96 + Math.pow(Math.abs(this.aveRssi), 3) % 10 / 150;
		if (ratio < 1) {
			distance = Math.pow(ratio, 9.98) * d;
		} else { 
			distance = 0.103 + 0.89978 * Math.pow(ratio, 9) * d;
		}
		return distance;
	}
};

/**
 * 算法模块
 */
class Algorithm {
	constructor() {
		this.position = {};
		this.floorbeacons = {};
	}
	clearRssiChain(b) {
		for (let i = 0; i < b.size(); i++) { 
			b[i]['rssiChain']['length'] = 0;
		} 
	}
	getPosition(x, y, g, e) {
		for (let i = 0; i < g.length; i++) {
			let c = 0;
			let a = 0;
			if (g[i].rssiChain.length == 5) { 
				g[i].rssiChain.shift() 
			}
			if (g[i].accuracyChain.length == 5) { 
				g[i].accuracyChain.shift() 
			}
			for (let j = 0; j < e.length; j++) {
				if (g[i].minor == e[j].minor && g[i].major == e[j].major) { 
					a = j;
					c = 1;
					break 
				} 
			}
			if (c == 1) { 
				g[i].rssiChain.push(Number(e[a].rssi));
				g[i].accuracyChain.push(Number(e[a].accuracy));
				g[i].measuredPower = -59;
			} else { 
				g[i].rssiChain.push(0);
				g[i].accuracyChain.push(0);
			} 
		}
		let sumXD = 0;
		let sumYD = 0;
		let sumD = 0;
		let sumAD = 0;
		let lowDis = 10;
		for (let o = 0; o < g.length; o++) {
			let n = g[o].aveRssi;
			if (g[o].distance != 0 && g[o].effCount >= 2) { // 距离不为0，有效rssi数量大于等于2
				sumXD = sumXD + g[o].x / (g[o].distance * g[o].distance);
				sumYD = sumYD + g[o].y / (g[o].distance * g[o].distance);
				sumD = sumD + 1 / (g[o].distance * g[o].distance);
				sumAD = sumAD + g[o].accuary / (g[o].distance * g[o].distance);
				if (g[o].distance < lowDis) { 
					lowDis = g[o].distance;
				} 
			}
		}
		if (sumD != 0) { 
			sumXD = sumXD / sumD;
			sumYD = sumYD / sumD;
			this.position.X = sumXD;
			this.position.Y = sumYD;
			this.position.accuracy = sumAD / sumD;
			return this.position;
		} else { 
			this.position.X = x;
			this.position.Y = y;
			this.position.accuracy = 0;
			return this.position;
		}
	}
	getPositionWithFilter(realX, realY, groupID, mBeaconList, pureBeaconList, isLocationInit) {
		let limitRssi = -100; // rssi的限制，比它小则视为无效， 大则记录
		let highBeaconIndexInPure = 0; // 信号最强beacon在pureBeaconList的序号位置
		let floorId; // 获取信号最强beacon的楼层
		let flagForHasGetFloor = 0; // 标志已经获得信号最强beacon的楼层
		let waitBeacon = []; // 同所在楼层所有beacon对象数组
		if (isLocationInit) { // 如果是初始化时
			this.position.X = 0;
			this.position.Y = 0;
			for (let s = 0; s < pureBeaconList.length; s++) {
				let temRssi = parseInt(pureBeaconList[s].rssi);
				limitRssi = parseInt(limitRssi);
				if (temRssi >= limitRssi) {
					limitRssi = temRssi;
					for (let d = 0; d < mBeaconList.length; d++) {
						if (pureBeaconList[s].minor == mBeaconList[d].minor && pureBeaconList[s].major == mBeaconList[d].major) {
							this.position.X = mBeaconList[d].x;
							this.position.Y = mBeaconList[d].y;
							this.position.floorid = mBeaconList[d].floorid;
							this.position.distance = getFirstDistance(limitRssi);
						}
					}
				}
			}
			return this.position;
		}

		for (let b = 0; b < pureBeaconList.length; b++) { // 找出信号最强的beacon
			let temRssi = parseInt(pureBeaconList[b].rssi);
			limitRssi = parseInt(limitRssi);
			if (temRssi >= limitRssi) {
				limitRssi = temRssi;
				highBeaconIndexInPure = b;
			}
		}

		for (let t = 0; t < mBeaconList.length; t++) { // 获取信号最强的beacon所在楼层极为用户位置
			if (pureBeaconList[highBeaconIndexInPure].minor == mBeaconList[t].minor && pureBeaconList[highBeaconIndexInPure].major == mBeaconList[t].major) {
				floorId = mBeaconList[t].floorid;
				flagForHasGetFloor = 1;
				break
			}
		}

		if (flagForHasGetFloor === 1) { // 如果获取的到最强信号beacon的楼层，则将对应楼层的beacon对象推入待用数组中
			for (let a = 0; a < mBeaconList.length; a++) {
				if (mBeaconList[a].floorid == floorId) {
					waitBeacon.push(mBeaconList[a])
				}
			}
		}

		for (let t = 0; t < waitBeacon.length; t++) { // 保存接受到的rssi到对应的beacon中，最多保存5个
			let flagInSameFloor = 0; // 标记接受到的beacon中 =>（满足在同楼层的beacon对象列表里信息）
			let tmpBeaconIndex = 0; // 临时记录接受到的beacon序号（满足在同楼层的beacon对象列表里信息）
			if (waitBeacon[t].rssiChain.length == 5) { // 历史超过5个rssi，去掉最老的
				waitBeacon[t].rssiChain.shift();
			}
			for (let k = 0; k < pureBeaconList.length; k++) { // 接受到的beacon信号强度大于-90且有效（!=0）
				if (waitBeacon[t].minor == pureBeaconList[k].minor && waitBeacon[t].major == pureBeaconList[k].major && pureBeaconList[k].rssi > -90 && pureBeaconList[k].rssi != 0) {
					tmpBeaconIndex = k;
					flagInSameFloor = 1;
					break;
				}
			}
			if (flagInSameFloor == 1) { // 接收到该beacon
				waitBeacon[t].rssiChain.push(Number(pureBeaconList[tmpBeaconIndex].rssi)); // 保存历史5个同beacon的rssi
				waitBeacon[t].measuredPower = -59; // 估计是测量时1m处的beacon的rssi
			} else { // 未接收到该beacon
				waitBeacon[t].rssiChain.push(0);
			}
		}

		let avgSumX = 0;
		let avgSumY = 0;
		let avgSumDis = 0;
		let minDis = 10;
		for (let e = 0; e < waitBeacon.length; e++) {
			// let c = waitBeacon[e].aveRssi; // 获取该beacon历史平均rssi强度
			if (waitBeacon[e].distance != 0 && waitBeacon[e].effCount >= 2) { // 距离不为0，有效rssi数量大于等于2
				avgSumX = avgSumX + waitBeacon[e].x / (waitBeacon[e].distance * waitBeacon[e].distance);
				avgSumY = avgSumY + waitBeacon[e].y / (waitBeacon[e].distance * waitBeacon[e].distance);
				avgSumDis = avgSumDis + 1 / (waitBeacon[e].distance * waitBeacon[e].distance);
				if (waitBeacon[e].distance < minDis) {
					minDis = waitBeacon[e].distance;
				}
			}
		}
		if (avgSumDis != 0) {
			avgSumX = avgSumX / avgSumDis;
			avgSumY = avgSumY / avgSumDis;
			this.position.X = avgSumX; // x的估算位置
			this.position.Y = avgSumY; // y的估算位置
			this.position.floorid = floorId;
			this.position.distance = minDis; // 离得最近的beacon距离
			return this.position;
		} else {
			this.position.X = realX;
			this.position.Y = realY;
			this.position.floorid = groupID;
			this.position.distance = minDis;
			return this.position;
		}
	}
};

class SensorLink {
	constructor(sensor) {
		this.element = sensor;
		this.next = null;
	}
};

class LinkedList {
	constructor() {
		this.counter = 0;
		this.firstSensorLink = null;
	}
	append(sensor) {
		let sensorLink = new SensorLink(sensor),
			temLast;
		if (this.firstSensorLink === null) {
			this.firstSensorLink = sensorLink;
		} else {
			temLast = this.firstSensorLink;
			while (temLast.next) {
				temLast = temLast.next;
			}
			temLast.next = sensorLink;
		}
		this.counter++;
	}
	offer(sensor) {
		this.append(sensor);
	}
	insert(index, sensor) {
		if (index >= 0 && index <= this.counter) {
			let sensorLink = new SensorLink(sensor),
				temLast = this.firstSensorLink,
				parentSensor, indexCounter = 0;
			if (index === 0) {
				sensorLink.next = temLast;
				this.firstSensorLink = sensorLink;
			} else {
				while (indexCounter++ < index) {
					parentSensor = temLast;
					temLast = temLast.next;
				}
				sensorLink.next = temLast;
				parentSensor.next = sensorLink;
			}
			this.counter++;
			return true;
		} else {
			return false;
		}
	}
	get(index) {
		if (index > -1 && index < this.counter) {
			var temLast = this.firstSensorLink,
				parentSensor, indexCounter = 0;
			if (index === 0) {
				return this.firstSensorLink.element;
			} else {
				while (indexCounter++ < index) {
					parentSensor = temLast;
					temLast = temLast.next;
				}
			}
			return temLast.element;
		} else {
			return null;
		}
	}
	removeAt(index) {
		if (index > -1 && index < this.counter) {
			let temLast = this.firstSensorLink,
				parentSensor, indexCounter = 0;
			if (index === 0) {
				this.firstSensorLink = temLast.next;
			} else {
				while (indexCounter++ < index) {
					parentSensor = temLast;
					temLast = temLast.next;
				}
				parentSensor.next = temLast.next;
			}
			this.counter--;
			return temLast.element;
		} else {
			return null;
		}
	}
	clear() {
		this.firstSensorLink = null;
		this.counter = 0;
	}
	remove(sensor) {
		let index = this.indexOf(sensor);
		return this.removeAt(index);
	}
	indexOf(sensor) {
		let temLast = this.firstSensorLink,
			index = -1;
		while (temLast) {
			if (sensor === temLast.element) {
				return index;
			}
			index++;
			temLast = temLast.next;
		}
		return -1;
	}
	poll() {
		return this.counter > 0 ? this.removeAt(0) : null;
	}
	isEmpty() {
		return this.counter === 0;
	}
	size() {
		return this.counter;
	}
	toString() {
		var temLast = this.firstSensorLink,
			linkedString = "";
		while (temLast) {
			linkedString += temLast.element;
			temLast = temLast.next;
		}
		return linkedString;
	}
	getHead() {
		return this.firstSensorLink;
	}
};


// 通过rssi获取初始位置距离
function getFirstDistance(rssi) {
	rssi = parseInt(rssi);
	let dis = 0;
	let ratio = rssi / -59;
	let fixed = 0.96 + Math.pow(Math.abs(rssi), 3) % 10 / 150;
	if (ratio < 1) {
		dis = Math.pow(ratio, 9.98) * fixed;
	} else {
		dis = 0.103 + 0.89978 * Math.pow(ratio, 9) * fixed
	}
	return dis;
}


function getNS(interval) { // 转成s
	if (interval >= 1) { // 部分浏览器回ms
		return parseFloat(interval / 1000);
	} else { // 部分浏览器回s
		return parseFloat(interval);
	}
}

let isLocationInit = true; // 定位初始化
let mBeaconList = []; // Beacon对象列表
let MAP_ID; // 地图ID
let USER; // 当前用户的唯一识别码
let URL_GET_BEACON_LIST = "http://sz.odinsoft.com.cn/api/v1/beacons";
let URL_GET_POSITION = "http://sj.yunweizhi.net/pdr/getPosition";
let positionCallBack = {}; // 位置更新回调函数
let lastBleLocation = { time: 0, reliable: false }; // time: 上一次定位的时间，reliable: 是否可靠
let realLocation = { x: 0, y: 0, groupID: 1 }; // 具体定位点位置
let stepLock = false;
let bleLock = false; // 设置定位点锁，防止过快的更新导致位置信息错误
let lostBounds = [
	{
		swX: 13539248.698662221,
		swY: 3667219.0552632664,
		neX: 13539217.22034286,
		neY: 3667154.3095923006
	},
	{
		swX: 13539325.698759986,
		swY: 3667219.204487914,
		neX: 13539294.063060585,
		neY: 3667152.0532385954
	}
];

function onStep(stepHeading, stepLength, stepCount) {
	if (stepLock) {
		return '';
	}
	if (realLocation.x === 0 && realLocation.y === 0) {
		return '';
	}
	stepLock = true;
	if (bleLock || true) {
		let rad = Math.PI / 180 * (360 - stepHeading);
		let nowX = realLocation.x + stepLength * Math.sin(rad);
		let nowY = realLocation.y + stepLength * Math.cos(rad);
		realLocation.x = nowX;
		realLocation.y = nowY;
		positionCallBack.updatePosition(realLocation.x, realLocation.y, realLocation.groupID)
	} else {
		// let f = getCurrentTimestamp();
		// $.ajax({
		// 	url: URL_GET_POSITION,
		// 	type: 'POST',
		// 	async: true,
		// 	timeout: 300,
		// 	data: {
		// 		x: realLocation.x,
		// 		y: realLocation.y,
		// 		stepLength: stepLength,
		// 		compassHeading: stepHeading,
		// 		floor: realLocation.groupID,
		// 		mapID: MAP_ID,
		// 		// timestamp: getCurrentTime(),
		// 		hlKes4: f,
		// 		openId: USER
		// 	},
		// 	dataType: 'json',
		// 	success: function(j, i, h) {
		// 		if (j.code == 0) {
		// 			realLocation.x = j.data.x;
		// 			realLocation.y = j.data.y;
		// 			positionCallBack.updatePosition(realLocation.x, realLocation.y, realLocation.groupID)
		// 		}
		// 	},
		// 	error: function(l, k) {
		// 		let j = Math.PI / 180 * (360 - stepHeading);
		// 		let h = realLocation.x + stepLength * Math.sin(j);
		// 		let i = realLocation.y + stepLength * Math.cos(j);
		// 		realLocation.x = h;
		// 		realLocation.y = i;
		// 		positionCallBack.updatePosition(realLocation.x, realLocation.y, realLocation.groupID)
		// 	}
		// });
	}
	stepLock = false;
}

function beaconLocation(position, nowTime) {
	if (position.X > 0 && position.Y > 0) {
		if (isLocationInit) { // 初始化定位
			lastBleLocation.time = nowTime; // 上次定位的时间
			lastBleLocation.reliable = position.distance < 4; // 定位距离小于4则可靠，否则不可靠
			bleSetPosition(position); // 设置定位点
			isLocationInit = false; // 初始化结束
		} else {
			if (isInLostBounds(realLocation)) { // 出了定位边界线
				let a = nowTime - lastBleLocation.time;
				if (a > 20000) { // 判断上次定位间隔时间，超过20s重置，并设为不可信
					lastBleLocation.time = nowTime;
					lastBleLocation.reliable = false;
					bleSetPosition(position);
				}
			} else {
				let d = nowTime - lastBleLocation.time;
				if (position.distance < 4) {
					if ((d > 5000 && d < 8000 && !lastBleLocation.reliable) || d > 10000) {
						lastBleLocation.time = nowTime;
						lastBleLocation.reliable = true;
						bleSetPosition(position);
					}
				} else {
					if (position.distance < 10) {
						if ((d > 5000 && !lastBleLocation.reliable) || d > 12000) {
							lastBleLocation.time = nowTime;
							lastBleLocation.reliable = false;
							bleSetPosition(position);
						}
					} else {
						if (d > 15000) {
							lastBleLocation.time = nowTime;
							lastBleLocation.reliable = false;
							bleSetPosition(position);
						}
					}
				}
			}
		}
	}
}

function bleSetPosition(position) {
	bleLock = true;
	realLocation.x = position.X;
	realLocation.y = position.Y;
	realLocation.groupID = position.floorid;
	positionCallBack.updatePosition(realLocation.x, realLocation.y, realLocation.groupID);
	bleLock = false;
}

function isInLostBounds(position) { // 判断点是否在定位范围内
	if (position.groupID == 2) {
		return true;
	}
	for (let b = 0; b < lostBounds.length; b++) {
		if (isPointInRect(position, lostBounds[b])) {
			return true;
		}
	}
	return false;
}

function isPointInRect(position, range) { // 点在矩形区域内
	return (position.x <= range.swX && position.x >= range.neX && position.y <= range.swY && position.y >= range.neY);
}

function getBeaconListFromService(mapId) {
	if (mBeaconList.length == 0) {
		$.ajax({
			url: URL_GET_BEACON_LIST,
			type: "POST",
			async: true,
			data: {
				key: "AhEvYZ1mYret7DkC", // AhEvYZ1mYret7DkC
				mapID: mapId
			},
			dataType: "json", // json
			success: function(res, e, f) {
				if (res.errcode == -1) {
					let c = res.data;
					if (c != null) {
						for (let d = 0; d < c.length; d++) {
							let beacon = new Beacon();
							beacon.x = c[d].posX;
							beacon.y = c[d].posY;
							beacon.floorid = c[d].groupID;
							beacon.major = c[d].major;
							beacon.minor = c[d].minor;
							mBeaconList.push(beacon) 
						} 
					}
					return
				} else {
					setTimeout(function() {
						getBeaconListFromService(mapId);
					}, 5000)
				}
			},
			error: function(c, b) {
				setTimeout(function() {
					getBeaconListFromService(mapId);
				}, 5000)
			}
		})
	}
}

let PositionModel = { // 运动基本情况
	createNew: function() {
		let positionState = {};
		positionState.stepHeading = 0;
		positionState.stepLength = 0;
		positionState.stepCount = 0;
		positionState.timestamp = 0;
		positionState.duration = 0;
		positionState.motion = MOTION_TEXTING; // 初始值为0
		positionState.process = function() {
			if (this.stepLength > 2 || this.stepLength < -2) { 
				this.stepLength = 0.7;
			}
			if (this.motion != MOTION_HAND_SWING) { // 非晃动
				this.stepCount++; // 累计步数
				onStep(this.stepHeading, this.stepLength, this.stepCount);
			}
		};
		return positionState;
	}
};

const SHORT_WINDOW_SIZE = 0.2; // 短采样时间上限（0.2s）
const LONG_WINDOW_SIZE = 1; // 长采样时间上限（1s）
const ENERGY_THRESHOLD = 0.025; // 下限
const DEFAULT_STEPLENGTH = 0.7; // 基础步伐

let MovingAverageStepDetector = {
	createNew: function() {
		let stepCondition = {};
		stepCondition.shortMovingWindow = MovingWindow.createNew(SHORT_WINDOW_SIZE); // 短采样移动
		stepCondition.longMovingWindow = MovingWindow.createNew(LONG_WINDOW_SIZE);
		stepCondition.stepWindow = SW.createNew();
		stepCondition.lastAccAmp = 0; // 综合加速度
		stepCondition.isFirstEvent = true; // 是否是第一次监测
		stepCondition.oldSwapState = true;
		stepCondition.energyThreshold = ENERGY_THRESHOLD; // 0.025
		stepCondition.processEvent = function(event) {
			let accX = event.accelerationIncludingGravity.x;
			let accY = event.accelerationIncludingGravity.y;
			let accZ = event.accelerationIncludingGravity.z;
			let detectSecond = getNS(event.interval);
			if (this.isFirstEvent) { // 第一次监测
				this.isFirstEvent = false;
				this.lastAccAmp = Math.sqrt(accX * accX + accY * accY + accZ * accZ); // 综合带重力加速度
			} else {
				let complexAcc = Math.sqrt(accX * accX + accY * accY + accZ * accZ); // 综合带重力加速度
				let sensorInfo = SensorSample.createNew(detectSecond, (this.lastAccAmp + complexAcc) / 2);
				this.shortMovingWindow.add(sensorInfo);
				this.longMovingWindow.add(sensorInfo);
				let shortTermAcc = this.shortMovingWindow.getAverage(); // 0.2移动平均加速度
				let longTermAcc = this.longMovingWindow.getAverage(); // 1移动平均加速度
				let motionState = shortTermAcc > longTermAcc;
				let g = false; // 切换状态，且属于开始运动
				if (motionState != this.oldSwapState) { // 状态切换
					if (motionState) {
						g = true;
					}
					this.oldSwapState = motionState;
				}
				this.stepWindow.add(new Array(sensorInfo, SensorSample.createNew(detectSecond, shortTermAcc - longTermAcc)));
				let e = this.stepWindow.getEnergy();
				if (g && e >= this.energyThreshold && this.stepWindow.getDuration() > 0.33 && this.stepWindow.getDuration() < 2 && this.stepWindow.getPeakValue() - k > 0.7 && k - this.stepWindow.getValleyValue() > 0.2) {
					let temNow = +new Date();
					let stepDuration = this.stepWindow.getDuration();
					let temStepLength = StepLengthEstimator.binaryLinearStepLength(1 / stepDuration, this.stepWindow.getVariance()) + 0.03;
					notifyStepEvent(temNow, stepDuration, temStepLength);
				}
				if (g) {
					this.stepWindow.reset();
				}
			}
		};
		return stepCondition;
	}
};

let SW = {
	createNew: function() {
		let stepWindow = {};
		stepWindow.queue = new LinkedList();
		stepWindow.energy = 0;
		stepWindow.totalInterval = 0;
		stepWindow.valueSum = 0;
		stepWindow.peakValue = 0;
		stepWindow.valleyValue = 0;
		stepWindow.add = function(sensorArr) {
			this.queue.offer(sensorArr[0]);
			this.totalInterval += sensorArr[0].interval;
			this.valueSum += sensorArr[0].value * sensorArr[0].interval;
			this.energy += sensorArr[1].value * sensorArr[1].value * sensorArr[1].interval;
			if (sensorArr[0].value > this.peakValue) {
				this.peakValue = sensorArr[0].value;
			}
			if (sensorArr[0].value < this.valleyValue) {
				this.valleyValue = sensorArr[0].value;
			}
		};
		stepWindow.reset = function() {
			this.queue.clear();
			this.energy = 0;
			this.totalInterval = 0;
			this.valueSum = 0;
			this.peakValue = -100;
			this.valleyValue = 100;
		};
		stepWindow.getEnergy = function() {
			return this.energy;
		};
		stepWindow.getPeakValue = function() {
			return this.peakValue;
		};
		stepWindow.getValleyValue = function() {
			return this.valleyValue;
		};
		stepWindow.getFallGap = function() {
			return this.peakValue - this.valleyValue;
		};
		stepWindow.getDuration = function() {
			return this.totalInterval;
		};
		stepWindow.getAverage = function() {
			if (this.totalInterval > 0) {
				return this.valueSum / this.totalInterval;
			} else {
				return 9.8;
			}
		};
		stepWindow.getVariance = function() {
			let avgAcc = this.valueSum / this.totalInterval;
			let sumVariance = 0;
			for (let c = 0; c < this.queue.size(); c++) {
				let sensor = this.queue.get(c);
				sumVariance += (sensor.value - avgAcc) * (sensor.value - avgAcc) * sensor.interval
			}
			return sumVariance / this.totalInterval;
		};
		return stepWindow;
	}
};

let MovingWindow = { 
	createNew: function(sampleSize) {
		var moveWindow = {};
		moveWindow.windowSize = sampleSize; // 采样时间上限
		moveWindow.queue = new LinkedList();
		moveWindow.totalInterval = 0;
		moveWindow.valueSum = 0;
		moveWindow.valueAverage = 0;
		moveWindow.add = function(sensor) {
			while (this.totalInterval > this.windowSize) {
				let removeSensor = this.queue.poll();
				if (removeSensor != null) {
					this.totalInterval -= removeSensor.interval;
					this.valueSum -= removeSensor.value * removeSensor.interval;
				}
			}
			this.queue.offer(sensor);
			this.totalInterval += sensor.interval;
			this.valueSum += sensor.value * sensor.interval;
			this.valueAverage = this.valueSum / this.totalInterval;
		};
		moveWindow.getAverage = function() {
			return this.valueAverage; // 带重力历史平均加速度
		};
		return moveWindow;
	}
};

let SensorSample = { // 记录监听周期，综合加速度
	createNew: function(interval, avgAcc) {
		let sensor = {};
		sensor.interval = interval;
		sensor.value = avgAcc;
		return sensor;
	}
};

let StepEvent = { // 暂时没用
	createNew: function(timestamp, duration, stepLength) {
		let stepInfo = {};
		stepInfo.timestamp = timestamp;
		stepInfo.duration = duration;
		stepInfo.stepLength = stepLength;
		return stepInfo;
	}
};

let StepLengthEstimator = {
	constantStepLength: function() {
		return DEFAULT_STEPLENGTH
	},
	unitaryLinearStepLength: function(d) {
		let c = 0.3074;
		let e = 0.3963;
		return c * d + e
	},
	binaryLinearStepLength: function(frequency, avgAcc) {
		let g = 0.1793;
		let f = 0.01122;
		let e = 0.3388;
		return g * frequency + f * avgAcc + e;
	},
	heightExperienceStepLength: function(f, d, c) {
		let g = 0.371;
		let e = 0.227;
		return c * (0.7 + g * (f - 1.75) + e * ((d - 1.79) * f / 1.75))
	}
};

const MOTION_TEXTING = 0;
const MOTION_CALLING = 1;
const MOTION_POCKET = 2;
const MOTION_HAND_SWING = 3;
const MOTION_UNKNOWN = 5;

let PhoneGestureDetector = {
	createNew: function() {
		let detectorInfo = {};
		detectorInfo.gravityData = new Array();
		detectorInfo.gravityData[0] = new Array();
		detectorInfo.gravityData[1] = new Array();
		detectorInfo.gravityData[2] = new Array();
		detectorInfo.linearaccData = new Array();
		detectorInfo.linearaccData[0] = new Array();
		detectorInfo.linearaccData[1] = new Array();
		detectorInfo.linearaccData[2] = new Array();
		detectorInfo.amplitude = new Array();
		detectorInfo.gravitySize = 0; // 带重力的加速度变化次数
		detectorInfo.linearaccSize = 0; // 不带重力的加速度变化次数
		detectorInfo.instances = new Array();
		detectorInfo.lastGesture = -1;
		detectorInfo.getMean = function(accArr, accCount) { // 历史平均加速度
			if (accCount == 0) {
				return 0;
			}
			let historySumAcc = 0; // 历史加速度和
			for (let i = 0; i < accCount; i++) {
				historySumAcc += accArr[i];
			}
			return parseFloat(historySumAcc / accCount);
		};
		detectorInfo.getgesture = function() {
			this.instances[0] = this.getMean(this.gravityData[0], this.gravitySize); // x历史平均重力加速度
			this.instances[1] = this.getMean(this.gravityData[1], this.gravitySize); // y历史平均重力加速度
			this.instances[2] = this.getMean(this.gravityData[2], this.gravitySize); // z历史平均重力加速度
			for (let i = 0; i < this.linearaccSize; i++) { // 各个时期不带重力加速度的综合加速度
				this.amplitude[i] = parseFloat(Math.sqrt(this.linearaccData[0][i] * this.linearaccData[0][i] + this.linearaccData[1][i] * this.linearaccData[1][i] + this.linearaccData[2][i] * this.linearaccData[2][i]));
			}
			this.instances[3] = this.getMean(this.amplitude, this.linearaccSize); // 历史平均综合不带重力加速度
			this.gravitySize = 0; // 清空重力加速度计数
			this.linearaccSize = 0; // 清空不带重力加速度计数
			let gestureCategoryId = DecisionTreeClassifier.classify(this.instances);
			let gestureCategory = MOTION_UNKNOWN;
			if (gestureCategoryId == 0) {
				gestureCategory = MOTION_CALLING;
			} else if (gestureCategoryId == 1) {
				gestureCategory = MOTION_HAND_SWING;
			} else if (gestureCategoryId == 2) {
				gestureCategory = MOTION_POCKET;
			} else if (gestureCategoryId == 3) {
				gestureCategory = MOTION_TEXTING;
			}
			return gestureCategory;
		};
		detectorInfo.processEvent = function(i) {
			let accWithGraX = i.accelerationIncludingGravity.x;
			let accWithGraY = i.accelerationIncludingGravity.y;
			let accWithGraZ = i.accelerationIncludingGravity.z;
			this.gravityData[0][this.gravitySize] = Math.abs(accWithGraX);
			this.gravityData[1][this.gravitySize] = Math.abs(accWithGraY);
			this.gravityData[2][this.gravitySize] = Math.abs(accWithGraZ);
			this.gravitySize++;
			let accX = i.acceleration.x;
			let accY = i.acceleration.y;
			let accZ = i.acceleration.z;
			this.linearaccData[0][this.linearaccSize] = accX;
			this.linearaccData[1][this.linearaccSize] = accY;
			this.linearaccData[2][this.linearaccSize] = accZ;
			this.linearaccSize++;
			if (this.linearaccSize >= 125 && this.gravitySize >= 125) {
				let gesture = this.getgesture();
				if (gesture != this.lastGesture) { // 设置现在的姿势
					this.lastGesture = gesture;
					notifyMotionEvent(gesture);
				}
			}
		};
		return detectorInfo;
	}
};

let DecisionTreeClassifier = {
	classify: function(accArr) {
		try {
			return parseInt(DecisionTreeClassifier.N40343d1e0(accArr))
		} catch (e) {
			return -1
		}
	},
	N40343d1e0: function(accArr) {
		let b = NaN;
		if (accArr[3] == null || accArr[3] == NaN) { // 历史平均综合不带重力加速度
			b = 3;
		} else if (accArr[3] <= 3.38336) { // 历史平均综合不带重力加速度小于等于3.38336
			b = DecisionTreeClassifier.N61c4b6501(accArr); // 判断z轴带重力加速度
		} else if (accArr[3] > 3.38336) { // 历史平均综合不带重力加速度大于3.38336
			b = DecisionTreeClassifier.N330866432(accArr); // 判断y轴带重力加速度
		}
		return b;
	},
	N61c4b6501: function(accArr) { // 判断z轴带重力加速度
		let b = NaN;
		if (accArr[2] == null || accArr[2] == NaN) {
			b = 0;
		} else if (accArr[2] <= 4.31389) {
			b = 0;
		} else if (accArr[2] > 4.31389) {
			b = 3;
		}
		return b;
	},
	N330866432: function(accArr) { // 判断y轴带重力加速度
		let b = NaN;
		if (accArr[1] == null || accArr[1] == NaN) {
			b = 1;
		} else if (accArr[1] <= 7.15387) {
			b = 1;
		} else if (accArr[1] > 7.15387) {
			b = 2;
		}
		return b;
	}
};

let md1 = MovingAverageStepDetector.createNew();
let sd1 = PhoneGestureDetector.createNew();
let pm1 = PositionModel.createNew(); // 基本运动情况的对象

function motionHandler(a) {
	md1.processEvent(a);
	sd1.processEvent(a);
}

function notifyStepEvent(c, a, b) {
	pm1.timestamp = c;
	pm1.duration = a;
	pm1.stepLength = b;
	pm1.process();
}

function notifyMotionEvent(a) { // 设置姿势
	pm1.motion = a;
}

// 初始化步行
function initPdrPosition(identifier, callback) { 
	USER = identifier; // 唯一识别符
    MAP_ID = "mediasoc1002"; // 地图id
    if (window.DeviceMotionEvent) { // 朝向
    	window.addEventListener("devicemotion", motionHandler, false);
    }
    compassHeadingHandler(0); // 指南针朝向更新
    positionCallBack.updatePosition = callback; // 地址更新的回调方法
    getBeaconListFromService(MAP_ID); // 从服务器更新beacon列表
}

// 指南针朝向实时更新
function compassHeadingHandler(angle) {
	pm1.stepHeading = angle; // 角度，与北的角度，顺时针为正
}

// 更新beacon列表
function bleLocation(beaconList) {
    var unixNow = +new Date(); // 时间戳（ms）
    var pureBeaconList = []; // 过滤rssi后的beacon列表
    if (beaconList != null && beaconList.length > 0 && mBeaconList.length > 0) {
        for (var i = 0; i < beaconList.length; i++) {
            if (beaconList[i]["rssi"] != 0) {
            	pureBeaconList.push(beaconList[i]);
            }
        }
        var ahm = new Algorithm(); // 算法
        var position = ahm.getPositionWithFilter(realLocation.x, realLocation.y, realLocation.groupID, mBeaconList, pureBeaconList, isLocationInit);
        beaconLocation(position, unixNow);
    }
}
